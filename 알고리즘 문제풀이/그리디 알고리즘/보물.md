문제
옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.

길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.

S = A[0] × B[0] + ... + A[N-1] × B[N-1]

S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.

S의 최솟값을 출력하는 프로그램을 작성하시오.

입력
첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.

출력
첫째 줄에 S의 최솟값을 출력한다.


```python
N = int(input())

A = list(map(int, input().split()))
B = list(map(int, input().split()))
S = 0
A.sort()

for i in range(N):
    S += A[i]*max(B)
    B.pop(B.index(max(B)))
    
print(S)
```

    3
    1 2 3
    4 5 6
    28


가장 최소의 합을 구하기 위해 그리디 알고리즘을 사용하였다.(A의 최솟값 X B의 최댓값)
A를 오름차순, B를 내림차순으로 정렬한 후 for문을 이용하여 같은 index 값끼리 곱해준다면 최솟값이 나오긴 하겠지만 이 문제에서 주의해야 할 점은, B에 있는 수를 재배열하면 안되는 것이다.

따라서, A만 오름차순으로 정렬해준 후 for문의 각 단계에서 max( ) 함수를 사용하여 B의 최댓값을 추출한 후, pop( ) 함수를 사용하여 B의 최댓값을 제거하고 반복문 다음 단계에서 B에서 다음으로 큰 수가 B의 최댓값이 되도록 설정해주면 된다.

